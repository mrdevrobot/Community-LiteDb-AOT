using LiteDB.Engine;
using Community.LiteDB.Aot.Collections;
using Community.LiteDB.Aot.Mapping;
using Community.LiteDB.Aot.ModelBuilder;

namespace Community.LiteDB.Aot.Context;

/// <summary>
/// Base class for AOT-compatible LiteDB context.
/// Similar to Entity Framework DbContext pattern.
/// </summary>
public abstract class LiteDbContext : IDisposable
{
    private readonly ILiteEngine _engine;
    private readonly Dictionary<Type, object> _collections = new();
    private readonly Dictionary<Type, object> _mappers = new();
    private bool _disposed;
    
    /// <summary>
    /// Initialize context with connection string (file path)
    /// </summary>
    protected LiteDbContext(string connectionString)
        : this(new LiteEngine(connectionString))
    {
    }
    
    /// <summary>
    /// Initialize context with engine settings
    /// </summary>
    protected LiteDbContext(EngineSettings settings)
        : this(new LiteEngine(settings))
    {
    }
    
    /// <summary>
    /// Initialize context with existing engine instance
    /// </summary>
    protected LiteDbContext(ILiteEngine engine)
    {
        _engine = engine ?? throw new ArgumentNullException(nameof(engine));
        
        // Register mappers (will be overridden by source generator)
        RegisterMappers();
        
        // Call OnModelCreating for user configuration
        var builder = new EntityModelBuilder();
        OnModelCreating(builder);
    }
    
    /// <summary>
    /// Override to configure model (used by source generator)
    /// </summary>
    protected virtual void OnModelCreating(EntityModelBuilder modelBuilder)
    {
    }
    
    /// <summary>
    /// Generated by source generator - registers all entity mappers
    /// </summary>
    protected virtual void RegisterMappers()
    {
        // Will be overridden by source generator in partial class
    }
    
    /// <summary>
    /// Register mapper for type T (called from generated RegisterMappers)
    /// </summary>
    protected void RegisterMapper<T>(IEntityMapper<T> mapper) where T : class
    {
        if (mapper == null) throw new ArgumentNullException(nameof(mapper));
        _mappers[typeof(T)] = mapper;
    }
    
    /// <summary>
    /// Get type-safe collection for entity type T
    /// </summary>
    protected AotLiteCollection<T> Collection<T>() where T : class
    {
        var type = typeof(T);
        
        // Return cached collection
        if (_collections.TryGetValue(type, out var cached))
        {
            return (AotLiteCollection<T>)cached;
        }
        
        // Get mapper
        if (!_mappers.TryGetValue(type, out var mapperObj))
        {
            throw new InvalidOperationException(
                $"No mapper registered for type '{type.Name}'. " +
                $"Make sure you configured it in OnModelCreating() and the source generator ran successfully.");
        }
        
        var mapper = (IEntityMapper<T>)mapperObj;
        var collection = new AotLiteCollection<T>(_engine, mapper);
        
        _collections[type] = collection;
        
        return collection;
    }
    
    #region Transactions
    
    /// <summary>
    /// Begin a new transaction
    /// </summary>
    public bool BeginTrans() => _engine.BeginTrans();
    
    /// <summary>
    /// Commit current transaction
    /// </summary>
    public bool Commit() => _engine.Commit();
    
    /// <summary>
    /// Rollback current transaction
    /// </summary>
    public bool Rollback() => _engine.Rollback();
    
    #endregion
    
    #region Maintenance
    
    /// <summary>
    /// Execute checkpoint operation
    /// </summary>
    public int Checkpoint() => _engine.Checkpoint();
    
    /// <summary>
    /// Rebuild database with options
    /// </summary>
    public long Rebuild(RebuildOptions options) => _engine.Rebuild(options);
    
    #endregion
    
    #region Dispose
    
    protected virtual void Dispose(bool disposing)
    {
        if (!_disposed)
        {
            if (disposing)
            {
                _engine?.Dispose();
            }
            _disposed = true;
        }
    }
    
    public void Dispose()
    {
        Dispose(true);
        GC.SuppressFinalize(this);
    }
    
    #endregion
}
