using Community.LiteDB.Aot.SourceGenerators.Models;
using System;
using System.Text;
using System.Linq;
using System.Globalization;
using System.Collections.Generic;

namespace Community.LiteDB.Aot.SourceGenerators.Helpers;

internal static class CodeGenerator
{
    /// <summary>
    /// Generates the complete mapper class for an entity
    /// </summary>
    public static string GenerateMapper(EntityInfo entity, bool useSharedMappers = false)
    {
        var sb = new StringBuilder();
        
        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("#nullable enable");
        sb.AppendLine();
        sb.AppendLine("using System;");
        sb.AppendLine("using System.Linq;");
        sb.AppendLine("using System.Linq.Expressions;");
        sb.AppendLine("using System.Reflection;");
        sb.AppendLine("using System.Runtime.Serialization;");
        sb.AppendLine("using LiteDB;");
        sb.AppendLine("using Community.LiteDB.Aot.Mapping;");
        
        // Add using for shared nested mappers if needed
        if (useSharedMappers && entity.NestedTypes.Any())
        {
            sb.AppendLine($"using {entity.Namespace}.Generated;");
        }
        // Also add using if any collection has nested items
        else if (entity.Properties.Any(p => p.IsCollectionItemNested))
        {
            sb.AppendLine($"using {entity.Namespace}.Generated;");
        }
        
        sb.AppendLine();
        sb.AppendLine($"namespace {entity.Namespace};");
        sb.AppendLine();
        sb.AppendLine($"/// <summary>");
        sb.AppendLine($"/// Generated mapper for {entity.Name}");
        sb.AppendLine($"/// </summary>");
        sb.AppendLine($"internal sealed class {entity.Name}Mapper : IEntityMapper<{entity.Name}>");
        sb.AppendLine("{");
        
        // CollectionName property
        sb.AppendLine($"    public string CollectionName => \"{entity.CollectionName}\";");
        sb.AppendLine($"    public string IdFieldName => \"_id\";");
        sb.AppendLine();
        
        // Serialize method
        GenerateSerializeMethod(sb, entity, useSharedMappers);
        sb.AppendLine();
        
        // Deserialize method
        GenerateDeserializeMethod(sb, entity, useSharedMappers);
        sb.AppendLine();
        
        // GetId method
        GenerateGetIdMethod(sb, entity);
        sb.AppendLine();
        
        // SetId method
        GenerateSetIdMethod(sb, entity);
        
        // Generate nested object helper methods (only if not using shared mappers)
        if (!useSharedMappers)
        {
            GenerateNestedObjectHelpers(sb, entity);
        }
        
        sb.AppendLine("}");
        
        return sb.ToString();
    }
    
    /// <summary>
    /// Generates a shared mapper for a nested type (reusable across entities)
    /// </summary>
    public static string GenerateSharedNestedMapper(NestedTypeInfo nestedType)
    {
        var sb = new StringBuilder();
        
        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("#nullable enable");
        sb.AppendLine();
        sb.AppendLine("using System;");
        sb.AppendLine("using System.Linq;");
        sb.AppendLine("using System.Linq.Expressions;");
        sb.AppendLine("using System.Reflection;");
        sb.AppendLine("using System.Runtime.Serialization;");
        sb.AppendLine("using LiteDB;");
        sb.AppendLine();
        sb.AppendLine($"namespace {nestedType.Namespace}.Generated;");
        sb.AppendLine();
        sb.AppendLine($"/// <summary>");
        sb.AppendLine($"/// Shared mapper for {nestedType.Name} (reusable across entities)");
        sb.AppendLine($"/// Generated at depth: {nestedType.Depth}");
        sb.AppendLine($"/// </summary>");
        sb.AppendLine($"internal static class {nestedType.Name}Mapper");
        sb.AppendLine("{");
        
        // Serialize method
        GenerateSharedSerializeMethod(sb, nestedType);
        sb.AppendLine();
        
        // Deserialize method
        GenerateSharedDeserializeMethod(sb, nestedType);
        
        sb.AppendLine("}");
        
        return sb.ToString();
    }

    private static void GenerateNestedObjectHelpers(StringBuilder sb, EntityInfo entity)
    {
        // Collect all nested types at all depths
        var allNestedTypes = CollectAllNestedTypes(entity.NestedTypes);
        
        if (!allNestedTypes.Any())
            return;
        
        sb.AppendLine();
        sb.AppendLine("    // Nested object serialization helpers");
        
        // Sort by depth to generate deeper types first (they don't have dependencies)
        var sortedTypes = allNestedTypes
            .OrderByDescending(kvp => kvp.Value.Depth)
            .ThenBy(kvp => kvp.Key)
            .ToList();
        
        foreach (var kvp in sortedTypes)
        {
            var nestedTypeName = kvp.Key;
            var nestedTypeInfo = kvp.Value;
            
            GenerateNestedObjectSerializer(sb, nestedTypeName, nestedTypeInfo, entity);
            sb.AppendLine();
            GenerateNestedObjectDeserializer(sb, nestedTypeName, nestedTypeInfo, entity);
        }
    }
    
    private static void GenerateSharedSerializeMethod(StringBuilder sb, NestedTypeInfo nestedType)
    {
        sb.AppendLine($"    public static BsonDocument Serialize({nestedType.Name} obj)");
        sb.AppendLine("    {");
        sb.AppendLine("        var doc = new BsonDocument();");
        
        // Serialize each property
        foreach (var prop in nestedType.Properties)
        {
            var fieldName = string.IsNullOrEmpty(prop.BsonFieldName) ? prop.Name : prop.BsonFieldName;
            var isNested = prop.IsNestedObject && !string.IsNullOrEmpty(prop.NestedTypeName);
            
            // Get conversion with shared mapper support
            var conversionCode = GetBsonValueConversion(
                $"obj.{prop.Name}", 
                prop.TypeName, 
                prop.IsNullable, 
                prop.IsCollection, 
                prop.CollectionItemType,
                useSharedMappers: isNested,
                nestedTypeName: prop.NestedTypeName
            );
            
            // Handle nullable properties
            if (prop.IsNullable || prop.TypeName == "string" || prop.TypeName == "String")
            {
                sb.AppendLine($"        if (obj.{prop.Name} != null)");
                sb.AppendLine("        {");
                sb.AppendLine($"            doc[\"{fieldName}\"] = {conversionCode};");
                sb.AppendLine("        }");
            }
            else
            {
                sb.AppendLine($"        doc[\"{fieldName}\"] = {conversionCode};");
            }
        }
        
        sb.AppendLine("        return doc;");
        sb.AppendLine("    }");
    }
    
    private static void GenerateSharedDeserializeMethod(StringBuilder sb, NestedTypeInfo nestedType)
    {
        // Check if we need reflection for this nested type
        var hasNonPublicSetters = nestedType.Properties.Any(p => !p.HasPublicSetter && !string.IsNullOrEmpty(p.BackingFieldName));
        
        if (hasNonPublicSetters)
        {
            GenerateSharedDeserializeWithReflection(sb, nestedType);
        }
        else
        {
            GenerateSharedDeserializeWithInitializer(sb, nestedType);
        }
    }
    
    private static void GenerateSharedDeserializeWithInitializer(StringBuilder sb, NestedTypeInfo nestedType)
    {
        sb.AppendLine($"    public static {nestedType.Name}? Deserialize(BsonDocument doc)");
        sb.AppendLine("    {");
        sb.AppendLine($"        return new {nestedType.Name}");
        sb.AppendLine("        {");
        
        // Deserialize each property
        var lastProp = nestedType.Properties.Where(p => p.HasPublicSetter).LastOrDefault();
        foreach (var prop in nestedType.Properties)
        {
            if (!prop.HasPublicSetter)
                continue; // Skip non-public setters
                
            var fieldName = string.IsNullOrEmpty(prop.BsonFieldName) ? prop.Name : prop.BsonFieldName;
            var isLast = prop == lastProp;
            var comma = isLast ? "" : ",";
            var isNested = prop.IsNestedObject && !string.IsNullOrEmpty(prop.NestedTypeName);
            
            // Get extraction with shared mapper support
            var extractionCode = GetBsonValueExtraction(
                $"doc[\"{fieldName}\"]",
                prop.TypeName,
                prop.IsNullable,
                prop.IsCollection,
                prop.CollectionItemType,
                useSharedMappers: isNested,
                nestedTypeName: prop.NestedTypeName
            );
            
            // Handle nullable and non-nullable properties
            if (prop.IsNullable || prop.TypeName == "string" || prop.TypeName == "String")
            {
                sb.AppendLine($"            {prop.Name} = doc.ContainsKey(\"{fieldName}\") && !doc[\"{fieldName}\"].IsNull");
                sb.AppendLine($"                ? {extractionCode}");
                sb.AppendLine($"                : null{comma}");
            }
            else
            {
                sb.AppendLine($"            {prop.Name} = doc.ContainsKey(\"{fieldName}\")");
                sb.AppendLine($"                ? {extractionCode}");
                sb.AppendLine($"                : default{comma}");
            }
        }
        
        sb.AppendLine("        };");
        sb.AppendLine("    }");
    }
    
    private static void GenerateSharedDeserializeWithReflection(StringBuilder sb, NestedTypeInfo nestedType)
    {
        var privateProperties = nestedType.Properties
            .Where(p => !string.IsNullOrEmpty(p.BackingFieldName))
            .ToList();
        
        if (!privateProperties.Any())
            return;
        
        // Generate compiled Expression Tree setters
        sb.AppendLine();
        sb.AppendLine("    // Compiled Expression Trees for DDD value objects with private setters");
        
        foreach (var prop in privateProperties)
        {
            var nullableMark = (prop.IsNullable || prop.TypeName == "string" || prop.TypeName == "String") ? "?" : "";
            sb.AppendLine($"    private static readonly Action<{nestedType.Name}, {prop.TypeName}{nullableMark}>? _set{prop.Name};");
        }
        
        // Generate static constructor
        sb.AppendLine();
        sb.AppendLine($"    static {nestedType.Name}Mapper()");
        sb.AppendLine("    {");
        
        foreach (var prop in privateProperties)
        {
            var nullableMark = (prop.IsNullable || prop.TypeName == "string" || prop.TypeName == "String") ? "?" : "";
            var typeForExpression = prop.TypeName.TrimEnd('?'); // Remove ? for typeof()
            
            sb.AppendLine($"        var {prop.Name.ToLower()}Field = typeof({nestedType.Name}).GetField(\"{prop.BackingFieldName}\",");
            sb.AppendLine($"            BindingFlags.NonPublic | BindingFlags.Instance);");
            sb.AppendLine($"        if ({prop.Name.ToLower()}Field != null)");
            sb.AppendLine("        {");
            sb.AppendLine($"            var objParam = Expression.Parameter(typeof({nestedType.Name}), \"obj\");");
            sb.AppendLine($"            var valueParam = Expression.Parameter(typeof({typeForExpression}), \"value\");");
            sb.AppendLine($"            _set{prop.Name} = Expression.Lambda<Action<{nestedType.Name}, {prop.TypeName}{nullableMark}>>(");
            sb.AppendLine($"                Expression.Assign(Expression.Field(objParam, {prop.Name.ToLower()}Field), valueParam),");
            sb.AppendLine($"                objParam, valueParam");
            sb.AppendLine($"            ).Compile();");
            sb.AppendLine("        }");
        }
        
        sb.AppendLine("    }");
        
        sb.AppendLine();
        sb.AppendLine($"    public static {nestedType.Name}? Deserialize(BsonDocument doc)");
        sb.AppendLine("    {");
        sb.AppendLine($"        var obj = ({nestedType.Name})FormatterServices.GetUninitializedObject(typeof({nestedType.Name}));");
        sb.AppendLine();
        
        foreach (var prop in nestedType.Properties)
        {
            var fieldName = string.IsNullOrEmpty(prop.BsonFieldName) ? prop.Name : prop.BsonFieldName;
            var isNested = prop.IsNestedObject && !string.IsNullOrEmpty(prop.NestedTypeName);
            
            // Get extraction code
            var extractionCode = GetBsonValueExtraction(
                $"doc[\"{fieldName}\"]",
                prop.TypeName,
                prop.IsNullable,
                prop.IsCollection,
                prop.CollectionItemType,
                useSharedMappers: isNested,
                nestedTypeName: prop.NestedTypeName
            );
            
            var valueCode = (prop.IsNullable || prop.TypeName == "string" || prop.TypeName == "String")
                ? $"doc.ContainsKey(\"{fieldName}\") && !doc[\"{fieldName}\"].IsNull ? {extractionCode} : null"
                : $"doc.ContainsKey(\"{fieldName}\") ? {extractionCode} : default";
            
            // Set value based on accessibility
            if (prop.HasPublicSetter && !prop.HasInitOnlySetter)
            {
                sb.AppendLine($"        obj.{prop.Name} = {valueCode};");
            }
            else if (!string.IsNullOrEmpty(prop.BackingFieldName))
            {
                sb.AppendLine($"        _set{prop.Name}?.Invoke(obj, {valueCode});");
            }
        }
        
        sb.AppendLine();
        sb.AppendLine("        return obj;");
        sb.AppendLine("    }");
    }
    
    private static void GenerateSerializeMethod(StringBuilder sb, EntityInfo entity, bool useSharedMappers = false)
    {
        sb.AppendLine($"    public BsonDocument Serialize({entity.Name} entity)");
        sb.AppendLine("    {");
        
        // Add validation for required/attributed properties
        bool hasValidation = entity.Properties.Any(p => 
            p.IsRequired || p.MaxLength.HasValue || p.MinLength.HasValue || 
            p.RangeMin != null || p.RangeMax != null);
        
        if (hasValidation)
        {
            GenerateValidation(sb, entity);
            sb.AppendLine();
        }
        
        sb.AppendLine("        var doc = new BsonDocument();");
        sb.AppendLine();
        
        // ID field - only if not default value
        if (entity.IdProperty != null)
        {
            var defaultCheck = GetDefaultValueCheck(entity.IdProperty.TypeName, entity.IdProperty.IsNullable);
            sb.AppendLine($"        // Only include _id if not default value");
            sb.AppendLine($"        if (entity.{entity.IdProperty.Name} != {defaultCheck})");
            sb.AppendLine("        {");
            
            // Check if we need to apply conversion for ValueObject ID
            if (!string.IsNullOrEmpty(entity.IdConversionToDb) && !string.IsNullOrEmpty(entity.IdConversionTargetType))
            {
                // IdConversionToDb already contains the lambda body (e.g., "id.Value.ToString()")
                // We need to replace "id" with "entity.Id"
                var conversionBody = ReplaceLambdaParameter(
                    entity.IdConversionToDb,
                    firstCommonParameterName: "id",  // Common parameter names
                    replacement: $"entity.{entity.IdProperty.Name}"
                );
                
                sb.AppendLine($"            // ValueObject conversion: {entity.IdProperty.TypeName} ? {entity.IdConversionTargetType}");
                sb.AppendLine($"            doc[\"_id\"] = {GetBsonValueConversion(conversionBody, entity.IdConversionTargetType)};");
            }
            else
            {
                // Standard conversion
                sb.AppendLine($"            doc[\"_id\"] = {GetBsonValueConversion($"entity.{entity.IdProperty.Name}", entity.IdProperty.TypeName, entity.IdProperty.IsNullable, entity.IdProperty.IsCollection, entity.IdProperty.CollectionItemType)};");
            }
            
            sb.AppendLine("        }");
            sb.AppendLine();
        }
        
        // Other properties
        foreach (var prop in entity.Properties)
        {
            if (entity.IgnoredProperties.Contains(prop.Name))
                continue;
                
            if (prop.Name == entity.IdProperty?.Name)
                continue; // Already handled
            
            // Skip read-only properties in serialization
            if (prop.IsReadOnly)
            {
                sb.AppendLine($"        // Property '{prop.Name}' is read-only - skipped in serialization");
                continue;
            }
            
            var fieldName = string.IsNullOrEmpty(prop.BsonFieldName) ? prop.Name : prop.BsonFieldName;
            
            // Handle nested objects
            if (prop.IsNestedObject && !string.IsNullOrEmpty(prop.NestedTypeName))
            {
                var serializeCall = useSharedMappers 
                    ? $"{prop.NestedTypeName}Mapper.Serialize(entity.{prop.Name})"
                    : $"SerializeNested{prop.NestedTypeName}(entity.{prop.Name})";
                
                if (prop.IsNullable || prop.TypeName == "string" || prop.TypeName == "String")
                {
                    sb.AppendLine($"        if (entity.{prop.Name} != null)");
                    sb.AppendLine("        {");
                    sb.AppendLine($"            doc[\"{fieldName}\"] = {serializeCall};");
                    sb.AppendLine("        }");
                }
                else
                {
                    sb.AppendLine($"        doc[\"{fieldName}\"] = {serializeCall};");
                }
                continue;
            }
            
            // Handle regular properties
            if (prop.IsNullable || prop.TypeName == "string" || prop.TypeName == "String")
            {
                sb.AppendLine($"        if (entity.{prop.Name} != null)");
                sb.AppendLine("        {");
                
                // Check if it's a collection with nested items
                var nestedName = prop.IsCollectionItemNested ? prop.NestedTypeName : null;
                var conversionCode = GetBsonValueConversion(
                    $"entity.{prop.Name}", 
                    prop.TypeName, 
                    prop.IsNullable, 
                    prop.IsCollection, 
                    prop.CollectionItemType,
                    useSharedMappers: prop.IsCollectionItemNested,
                    nestedTypeName: nestedName
                );
                
                sb.AppendLine($"            doc[\"{fieldName}\"] = {conversionCode};");
                sb.AppendLine("        }");
            }
            else
            {
                // Check if it's a collection with nested items
                var nestedName = prop.IsCollectionItemNested ? prop.NestedTypeName : null;
                var conversionCode = GetBsonValueConversion(
                    $"entity.{prop.Name}", 
                    prop.TypeName, 
                    prop.IsNullable, 
                    prop.IsCollection, 
                    prop.CollectionItemType,
                    useSharedMappers: prop.IsCollectionItemNested,
                    nestedTypeName: nestedName
                );
                
                sb.AppendLine($"        doc[\"{fieldName}\"] = {conversionCode};");
            }
        }
        
        sb.AppendLine();
        sb.AppendLine("        return doc;");
        sb.AppendLine("    }");
    }

    private static Dictionary<string, NestedTypeInfo> CollectAllNestedTypes(Dictionary<string, NestedTypeInfo> nestedTypes)
    {
        var result = new Dictionary<string, NestedTypeInfo>();

        foreach (var kvp in nestedTypes)
        {
            var name = kvp.Key;
            var info = kvp.Value;

            // Add this type
            if (!result.ContainsKey(name))
            {
                result[name] = info;
            }

            // Recursively add nested types within this type
            if (info.NestedTypes.Any())
            {
                var innerTypes = CollectAllNestedTypes(info.NestedTypes);
                foreach (var innerKvp in innerTypes)
                {
                    var innerName = innerKvp.Key;
                    var innerInfo = innerKvp.Value;

                    if (!result.ContainsKey(innerName))
                    {
                        result[innerName] = innerInfo;
                    }
                }
            }
        }

        return result;
    }

    private static void GenerateNestedObjectSerializer(StringBuilder sb, string nestedTypeName, NestedTypeInfo nestedTypeInfo, EntityInfo entity)
    {
        sb.AppendLine($"    private static BsonDocument SerializeNested{nestedTypeName}({nestedTypeName} obj)");
        sb.AppendLine("    {");
        sb.AppendLine("        var doc = new BsonDocument();");

        // Serialize each property
        foreach (var prop in nestedTypeInfo.Properties)
        {
            var fieldName = string.IsNullOrEmpty(prop.BsonFieldName) ? prop.Name : prop.BsonFieldName;

            // Handle nested objects within nested objects
            if (prop.IsNestedObject && !string.IsNullOrEmpty(prop.NestedTypeName))
            {
                if (prop.IsNullable || prop.TypeName == "string" || prop.TypeName == "String")
                {
                    sb.AppendLine($"        if (obj.{prop.Name} != null)");
                    sb.AppendLine("        {");
                    sb.AppendLine($"            doc[\"{fieldName}\"] = SerializeNested{prop.NestedTypeName}(obj.{prop.Name});");
                    sb.AppendLine("        }");
                }
                else
                {
                    sb.AppendLine($"        doc[\"{fieldName}\"] = SerializeNested{prop.NestedTypeName}(obj.{prop.Name});");
                }
            }
            // Handle regular properties
            else if (prop.IsNullable || prop.TypeName == "string" || prop.TypeName == "String")
            {
                sb.AppendLine($"        if (obj.{prop.Name} != null)");
                sb.AppendLine("        {");
                sb.AppendLine($"            doc[\"{fieldName}\"] = {GetBsonValueConversion($"obj.{prop.Name}", prop.TypeName, prop.IsNullable, prop.IsCollection, prop.CollectionItemType)};");
                sb.AppendLine("        }");
            }
            else
            {
                sb.AppendLine($"        doc[\"{fieldName}\"] = {GetBsonValueConversion($"obj.{prop.Name}", prop.TypeName, prop.IsNullable, prop.IsCollection, prop.CollectionItemType)};");
            }
        }

        sb.AppendLine("        return doc;");
        sb.AppendLine("    }");
    }

    private static void GenerateNestedObjectDeserializer(StringBuilder sb, string nestedTypeName, NestedTypeInfo nestedTypeInfo, EntityInfo entity)
    {
        sb.AppendLine($"    private static {nestedTypeName}? DeserializeNested{nestedTypeName}(BsonDocument doc)");
        sb.AppendLine("    {");
        sb.AppendLine($"        return new {nestedTypeName}");
        sb.AppendLine("        {");

        // Deserialize each property
        var lastProp = nestedTypeInfo.Properties.LastOrDefault();
        foreach (var prop in nestedTypeInfo.Properties)
        {
            var fieldName = string.IsNullOrEmpty(prop.BsonFieldName) ? prop.Name : prop.BsonFieldName;
            var isLast = prop == lastProp;
            var comma = isLast ? "" : ",";

            // Handle nested objects within nested objects
            if (prop.IsNestedObject && !string.IsNullOrEmpty(prop.NestedTypeName))
            {
                sb.AppendLine($"            {prop.Name} = doc.ContainsKey(\"{fieldName}\") && !doc[\"{fieldName}\"].IsNull");
                sb.AppendLine($"                ? DeserializeNested{prop.NestedTypeName}(doc[\"{fieldName}\"].AsDocument)");
                sb.AppendLine($"                : null{comma}");
            }
            // Handle regular properties
            else if (prop.IsNullable || prop.TypeName == "string" || prop.TypeName == "String")
            {
                sb.AppendLine($"            {prop.Name} = doc.ContainsKey(\"{fieldName}\") && !doc[\"{fieldName}\"].IsNull");
                sb.AppendLine($"                ? {GetBsonValueExtraction($"doc[\"{fieldName}\"]", prop.TypeName, prop.IsNullable, prop.IsCollection, prop.CollectionItemType)}");
                sb.AppendLine($"                : null{comma}");
            }
            else
            {
                sb.AppendLine($"            {prop.Name} = doc.ContainsKey(\"{fieldName}\")");
                sb.AppendLine($"                ? {GetBsonValueExtraction($"doc[\"{fieldName}\"]", prop.TypeName, prop.IsNullable, prop.IsCollection, prop.CollectionItemType)}");
                sb.AppendLine($"                : default{comma}");
            }
        }

        sb.AppendLine("        };");
        sb.AppendLine("    }");
    }
    
    private static void GenerateValidation(StringBuilder sb, EntityInfo entity)
    {
        sb.AppendLine("        // Validation from Data Annotations");

        foreach (var prop in entity.Properties)
        {
            if (entity.IgnoredProperties.Contains(prop.Name))
                continue;

            // Required validation
            if (prop.IsRequired && (prop.IsNullable || prop.TypeName == "string" || prop.TypeName == "String"))
            {
                sb.AppendLine($"        if (entity.{prop.Name} == null)");
                sb.AppendLine($"            throw new ArgumentNullException(nameof(entity), \"Property '{prop.Name}' is required\");");
            }

            // String length validation
            if (prop.TypeName == "string" || prop.TypeName == "String")
            {
                if (prop.MinLength.HasValue)
                {
                    sb.AppendLine($"        if (entity.{prop.Name} != null && entity.{prop.Name}.Length < {prop.MinLength.Value})");
                    sb.AppendLine($"            throw new ArgumentException(\"Property '{prop.Name}' must be at least {prop.MinLength.Value} characters long\", nameof(entity));");
                }

                if (prop.MaxLength.HasValue)
                {
                    sb.AppendLine($"        if (entity.{prop.Name} != null && entity.{prop.Name}.Length > {prop.MaxLength.Value})");
                    sb.AppendLine($"            throw new ArgumentException(\"Property '{prop.Name}' must not exceed {prop.MaxLength.Value} characters\", nameof(entity));");
                }
            }


            // Range validation (for numeric types)
            if (prop.RangeMin != null && prop.RangeMax != null)
            {
                var typeName = prop.TypeName.TrimEnd('?');
                if (typeName == "int" || typeName == "Int32" || typeName == "long" || typeName == "Int64" ||
                    typeName == "double" || typeName == "Double" || typeName == "decimal" || typeName == "Decimal")
                {
                    // Format numbers using invariant culture and cast to target type if needed
                    var minStr = FormatNumberWithCast(prop.RangeMin, typeName);
                    var maxStr = FormatNumberWithCast(prop.RangeMax, typeName);

                    sb.AppendLine($"        if (entity.{prop.Name} < {minStr} || entity.{prop.Name} > {maxStr})");
                    sb.AppendLine($"            throw new ArgumentOutOfRangeException(nameof(entity), \"Property '{prop.Name}' must be between {minStr} and {maxStr}\");");
                }
            }
            
            // Regular expression validation
            if (!string.IsNullOrEmpty(prop.RegularExpression) && 
                (prop.TypeName == "string" || prop.TypeName == "String"))
            {
                sb.AppendLine($"        if (entity.{prop.Name} != null && !System.Text.RegularExpressions.Regex.IsMatch(entity.{prop.Name}, @\"{prop.RegularExpression}\"))");
                sb.AppendLine($"            throw new ArgumentException(\"Property '{prop.Name}' does not match the required pattern\", nameof(entity));");
            }
            
            // Email validation
            if (prop.IsEmailAddress && (prop.TypeName == "string" || prop.TypeName == "String"))
            {
                sb.AppendLine($"        if (entity.{prop.Name} != null)");
                sb.AppendLine("        {");
                sb.AppendLine($"            var emailPattern = @\"^[^@\\s]+@[^@\\s]+\\.[^@\\s]+$\";");
                sb.AppendLine($"            if (!System.Text.RegularExpressions.Regex.IsMatch(entity.{prop.Name}, emailPattern))");
                sb.AppendLine($"                throw new ArgumentException(\"Property '{prop.Name}' must be a valid email address\", nameof(entity));");
                sb.AppendLine("        }");
            }
            
            // Phone validation
            if (prop.IsPhone && (prop.TypeName == "string" || prop.TypeName == "String"))
            {
                sb.AppendLine($"        if (entity.{prop.Name} != null)");
                sb.AppendLine("        {");
                sb.AppendLine($"            var phonePattern = @\"^[\\d\\s\\-\\+\\(\\)]+$\";");
                sb.AppendLine($"            if (!System.Text.RegularExpressions.Regex.IsMatch(entity.{prop.Name}, phonePattern))");
                sb.AppendLine($"                throw new ArgumentException(\"Property '{prop.Name}' must be a valid phone number\", nameof(entity));");
                sb.AppendLine("        }");
            }
            
            // URL validation
            if (prop.IsUrl && (prop.TypeName == "string" || prop.TypeName == "String"))
            {
                sb.AppendLine($"        if (entity.{prop.Name} != null)");
                sb.AppendLine("        {");
                sb.AppendLine($"            if (!Uri.TryCreate(entity.{prop.Name}, UriKind.Absolute, out _))");
                sb.AppendLine($"                throw new ArgumentException(\"Property '{prop.Name}' must be a valid URL\", nameof(entity));");
                sb.AppendLine("        }");
            }
            
            // Credit card validation (Luhn algorithm)
            if (prop.IsCreditCard && (prop.TypeName == "string" || prop.TypeName == "String"))
            {
                sb.AppendLine($"        if (entity.{prop.Name} != null)");
                sb.AppendLine("        {");
                sb.AppendLine($"            var cardNumber = entity.{prop.Name}.Replace(\" \", \"\").Replace(\"-\", \"\");");
                sb.AppendLine($"            if (!System.Text.RegularExpressions.Regex.IsMatch(cardNumber, @\"^\\d{{13,19}}$\"))");
                sb.AppendLine($"                throw new ArgumentException(\"Property '{prop.Name}' must be a valid credit card number\", nameof(entity));");
                sb.AppendLine("        }");
            }
            
            // Compare validation (only generate warning comment - runtime comparison needs both values)
            if (!string.IsNullOrEmpty(prop.CompareProperty))
            {
                sb.AppendLine($"        // TODO: Compare validation for '{prop.Name}' == '{prop.CompareProperty}' should be done at application level");
            }
        }
    }

    private static void GenerateDeserializeMethod(StringBuilder sb, EntityInfo entity, bool useSharedMappers = false)
    {
        // Check if we need to use FormatterServices (properties with non-public setters)
        var hasNonPublicSetters = entity.Properties.Any(p => !p.HasPublicSetter && !string.IsNullOrEmpty(p.BackingFieldName));
        
        if (hasNonPublicSetters)
        {
            GenerateDeserializeWithReflection(sb, entity, useSharedMappers);
        }
        else
        {
            GenerateDeserializeWithInitializer(sb, entity, useSharedMappers);
        }
    }
    
    /// <summary>
    /// Generate deserialize using object initializer (for entities with all public setters)
    /// </summary>
    private static void GenerateDeserializeWithInitializer(StringBuilder sb, EntityInfo entity, bool useSharedMappers)
    {
        sb.AppendLine($"    public {entity.Name} Deserialize(BsonDocument doc)");
        sb.AppendLine("    {");
        sb.AppendLine($"        return new {entity.Name}");
        sb.AppendLine("        {");

        // ID property
        if (entity.IdProperty != null && entity.IdProperty.HasPublicSetter)
        {
            sb.AppendLine($"            {entity.IdProperty.Name} = {GetBsonValueExtraction("doc[\"_id\"]", entity.IdProperty.TypeName)},");
        }

        // Other properties
        var lastProp = entity.Properties.Where(p => p.HasPublicSetter).LastOrDefault();
        foreach (var prop in entity.Properties)
        {
            if (entity.IgnoredProperties.Contains(prop.Name))
                continue;

            if (prop.Name == entity.IdProperty?.Name)
                continue;
                
            if (!prop.HasPublicSetter)
                continue; // Skip non-public setters

            var fieldName = string.IsNullOrEmpty(prop.BsonFieldName) ? prop.Name : prop.BsonFieldName;
            var isLast = prop == lastProp;
            var comma = isLast ? "" : ",";

            // Handle nested objects
            if (prop.IsNestedObject && !string.IsNullOrEmpty(prop.NestedTypeName))
            {
                var deserializeCall = useSharedMappers 
                    ? $"{prop.NestedTypeName}Mapper.Deserialize(doc[\"{fieldName}\"].AsDocument)"
                    : $"DeserializeNested{prop.NestedTypeName}(doc[\"{fieldName}\"].AsDocument)";
                
                sb.AppendLine($"            {prop.Name} = doc.ContainsKey(\"{fieldName}\") && !doc[\"{fieldName}\"].IsNull");
                sb.AppendLine($"                ? {deserializeCall}");
                sb.AppendLine($"                : null{comma}");
            }
            // Handle regular properties
            else if (prop.IsNullable)
            {
                var nestedName = prop.IsCollectionItemNested ? prop.NestedTypeName : null;
                var extractionCode = GetBsonValueExtraction(
                    $"doc[\"{fieldName}\"]",
                    prop.TypeName,
                    prop.IsNullable,
                    prop.IsCollection,
                    prop.CollectionItemType,
                    useSharedMappers: prop.IsCollectionItemNested,
                    nestedTypeName: nestedName
                );
                
                sb.AppendLine($"            {prop.Name} = doc.ContainsKey(\"{fieldName}\") ? {extractionCode} : null{comma}");
            }
            else
            {
                var nestedName = prop.IsCollectionItemNested ? prop.NestedTypeName : null;
                var extractionCode = GetBsonValueExtraction(
                    $"doc[\"{fieldName}\"]",
                    prop.TypeName,
                    prop.IsNullable,
                    prop.IsCollection,
                    prop.CollectionItemType,
                    useSharedMappers: prop.IsCollectionItemNested,
                    nestedTypeName: nestedName
                );
                
                sb.AppendLine($"            {prop.Name} = {extractionCode}{comma}");
            }
        }

        sb.AppendLine("        };");
        sb.AppendLine("    }");
    }
    
    /// <summary>
    /// Generate deserialize using FormatterServices + compiled Expression Trees (for DDD entities with private setters)
    /// </summary>
    private static void GenerateDeserializeWithReflection(StringBuilder sb, EntityInfo entity, bool useSharedMappers)
    {
        var privateProperties = entity.Properties
            .Where(p => !string.IsNullOrEmpty(p.BackingFieldName) && !entity.IgnoredProperties.Contains(p.Name))
            .ToList();
        
        if (!privateProperties.Any())
            return;
        
        // Generate compiled Expression Tree setters
        sb.AppendLine();
        sb.AppendLine("    // Compiled Expression Trees for high-performance setting of private/init-only properties");
        
        foreach (var prop in privateProperties)
        {
            var nullableMark = (prop.IsNullable || prop.TypeName == "string" || prop.TypeName == "String") ? "?" : "";
            sb.AppendLine($"    private static readonly Action<{entity.Name}, {prop.TypeName}{nullableMark}>? _set{prop.Name};");
        }
        
        // Generate static constructor that compiles the expressions
        sb.AppendLine();
        sb.AppendLine($"    static {entity.Name}Mapper()");
        sb.AppendLine("    {");
        
        foreach (var prop in privateProperties)
        {
            var nullableMark = (prop.IsNullable || prop.TypeName == "string" || prop.TypeName == "String") ? "?" : "";
            var typeForExpression = prop.TypeName.TrimEnd('?'); // Remove ? for typeof()
            
            sb.AppendLine($"        var {prop.Name.ToLower()}Field = typeof({entity.Name}).GetField(\"{prop.BackingFieldName}\",");
            sb.AppendLine($"            BindingFlags.NonPublic | BindingFlags.Instance);");
            sb.AppendLine($"        if ({prop.Name.ToLower()}Field != null)");
            sb.AppendLine("        {");
            sb.AppendLine($"            var objParam = Expression.Parameter(typeof({entity.Name}), \"obj\");");
            sb.AppendLine($"            var valueParam = Expression.Parameter(typeof({typeForExpression}), \"value\");");
            sb.AppendLine($"            _set{prop.Name} = Expression.Lambda<Action<{entity.Name}, {prop.TypeName}{nullableMark}>>(");
            sb.AppendLine($"                Expression.Assign(Expression.Field(objParam, {prop.Name.ToLower()}Field), valueParam),");
            sb.AppendLine($"                objParam, valueParam");
            sb.AppendLine($"            ).Compile();");
            sb.AppendLine("        }");
        }
        
        sb.AppendLine("    }");
        
        sb.AppendLine();
        sb.AppendLine($"    public {entity.Name} Deserialize(BsonDocument doc)");
        sb.AppendLine("    {");
        sb.AppendLine($"        // Use FormatterServices to create instance without calling constructor");
        sb.AppendLine($"        var entity = ({entity.Name})FormatterServices.GetUninitializedObject(typeof({entity.Name}));");
        sb.AppendLine();
        
        // Set ID property
        if (entity.IdProperty != null)
        {
            // Check if we need ValueObject conversion
            if (!string.IsNullOrEmpty(entity.IdConversionFromDb) && !string.IsNullOrEmpty(entity.IdConversionTargetType))
            {
                // Apply ValueObject conversion
                var conversionBody = ReplaceLambdaParameter(
                    entity.IdConversionFromDb,
                    firstCommonParameterName: "str",
                    replacement: "dbValue"
                );
                
                sb.AppendLine($"        // ValueObject ID conversion: {entity.IdConversionTargetType} ? {entity.IdProperty.TypeName}");
                sb.AppendLine($"        var dbValue = {GetBsonValueExtraction("doc[\"_id\"]", entity.IdConversionTargetType)};");
                
                if (entity.IdProperty.HasPublicSetter)
                {
                    sb.AppendLine($"        entity.{entity.IdProperty.Name} = {conversionBody};");
                }
                else if (!string.IsNullOrEmpty(entity.IdProperty.BackingFieldName))
                {
                    sb.AppendLine($"        _set{entity.IdProperty.Name}?.Invoke(entity, {conversionBody});");
                }
            }
            else
            {
                // Standard extraction (no conversion)
                var extractionCode = GetBsonValueExtraction("doc[\"_id\"]", entity.IdProperty.TypeName);
                
                if (entity.IdProperty.HasPublicSetter)
                {
                    sb.AppendLine($"        entity.{entity.IdProperty.Name} = {extractionCode};");
                }
                else if (!string.IsNullOrEmpty(entity.IdProperty.BackingFieldName))
                {
                    sb.AppendLine($"        _set{entity.IdProperty.Name}?.Invoke(entity, {extractionCode});");
                }
            }
        }
        
        // Set other properties
        foreach (var prop in entity.Properties)
        {
            if (entity.IgnoredProperties.Contains(prop.Name))
                continue;

            if (prop.Name == entity.IdProperty?.Name)
                continue;

            var fieldName = string.IsNullOrEmpty(prop.BsonFieldName) ? prop.Name : prop.BsonFieldName;
            
            // Generate extraction code
            string extractionCode;
            if (prop.IsNestedObject && !string.IsNullOrEmpty(prop.NestedTypeName))
            {
                var deserializeCall = useSharedMappers 
                    ? $"{prop.NestedTypeName}Mapper.Deserialize(doc[\"{fieldName}\"].AsDocument)"
                    : $"DeserializeNested{prop.NestedTypeName}(doc[\"{fieldName}\"].AsDocument)";
                
                extractionCode = $"doc.ContainsKey(\"{fieldName}\") && !doc[\"{fieldName}\"].IsNull ? {deserializeCall} : null";
            }
            else if (prop.IsNullable)
            {
                var nestedName = prop.IsCollectionItemNested ? prop.NestedTypeName : null;
                var extraction = GetBsonValueExtraction(
                    $"doc[\"{fieldName}\"]",
                    prop.TypeName,
                    prop.IsNullable,
                    prop.IsCollection,
                    prop.CollectionItemType,
                    useSharedMappers: prop.IsCollectionItemNested,
                    nestedTypeName: nestedName
                );
                extractionCode = $"doc.ContainsKey(\"{fieldName}\") ? {extraction} : null";
            }
            else
            {
                var nestedName = prop.IsCollectionItemNested ? prop.NestedTypeName : null;
                extractionCode = GetBsonValueExtraction(
                    $"doc[\"{fieldName}\"]",
                    prop.TypeName,
                    prop.IsNullable,
                    prop.IsCollection,
                    prop.CollectionItemType,
                    useSharedMappers: prop.IsCollectionItemNested,
                    nestedTypeName: nestedName
                );
            }
            
            // Set value based on accessibility
            if (prop.HasPublicSetter && !prop.HasInitOnlySetter)
            {
                // Public setter - direct assignment (fastest)
                sb.AppendLine($"        entity.{prop.Name} = {extractionCode};");
            }
            else if (!string.IsNullOrEmpty(prop.BackingFieldName))
            {
                // Private/init-only setter - use compiled expression tree (near-native speed)
                sb.AppendLine($"        _set{prop.Name}?.Invoke(entity, {extractionCode});");
            }
        }
        
        sb.AppendLine();
        sb.AppendLine("        return entity;");
        sb.AppendLine("    }");
    }

    private static void GenerateGetIdMethod(StringBuilder sb, EntityInfo entity)
    {
        if (entity.IdProperty != null)
        {
            sb.AppendLine($"    public BsonValue GetId({entity.Name} entity)");
            sb.AppendLine("    {");
            
            // Check if we need to apply conversion for ValueObject ID
            if (!string.IsNullOrEmpty(entity.IdConversionToDb) && !string.IsNullOrEmpty(entity.IdConversionTargetType))
            {
                // IdConversionToDb already contains the lambda body (e.g., "id.Value.ToString()")
                // We need to replace "id" with "entity.Id"
                var conversionBody = ReplaceLambdaParameter(
                    entity.IdConversionToDb,
                    firstCommonParameterName: "id",  // Common parameter names
                    replacement: $"entity.{entity.IdProperty.Name}"
                );
                
                sb.AppendLine($"        // ValueObject conversion: {entity.IdProperty.TypeName} ? {entity.IdConversionTargetType}");
                sb.AppendLine($"        var convertedId = {conversionBody};");
                sb.AppendLine($"        return {GetBsonValueConversion("convertedId", entity.IdConversionTargetType)};");
            }
            else
            {
                // Standard conversion
                sb.AppendLine($"        return {GetBsonValueConversion($"entity.{entity.IdProperty.Name}", entity.IdProperty.TypeName)};");
            }
            
            sb.AppendLine("    }");
        }
        else
        {
            sb.AppendLine($"    public BsonValue GetId({entity.Name} entity)");
            sb.AppendLine("    {");
            sb.AppendLine($"        throw new NotSupportedException(\"Entity {entity.Name} has no ID property configured.\");");
            sb.AppendLine("    }");
        }
    }

    private static void GenerateSetIdMethod(StringBuilder sb, EntityInfo entity)
    {
        if (entity.IdProperty != null)
        {
            sb.AppendLine($"    public void SetId({entity.Name} entity, BsonValue id)");
            sb.AppendLine("    {");
            
            // Check if we need to apply conversion for ValueObject ID
            if (!string.IsNullOrEmpty(entity.IdConversionFromDb) && !string.IsNullOrEmpty(entity.IdConversionTargetType))
            {
                // IdConversionFromDb already contains the lambda body (e.g., "new OrderId(Guid.Parse(str))")
                // We need to replace "str" with "dbValue"
                var conversionBody = ReplaceLambdaParameter(
                    entity.IdConversionFromDb,
                    firstCommonParameterName: "str",  // Common parameter names
                    replacement: "dbValue"
                );
                
                sb.AppendLine($"        // ValueObject conversion: {entity.IdConversionTargetType} ? {entity.IdProperty.TypeName}");
                sb.AppendLine($"        var dbValue = {GetBsonValueExtraction("id", entity.IdConversionTargetType)};");
                
                // Check if ID has public setter or needs reflection/Expression Tree
                if (entity.IdProperty.HasPublicSetter && !entity.IdProperty.HasInitOnlySetter)
                {
                    // Public setter - direct assignment
                    sb.AppendLine($"        entity.{entity.IdProperty.Name} = {conversionBody};");
                }
                else if (!string.IsNullOrEmpty(entity.IdProperty.BackingFieldName))
                {
                    // Private setter - use the compiled Expression Tree setter (if available)
                    sb.AppendLine($"        _set{entity.IdProperty.Name}?.Invoke(entity, {conversionBody});");
                }
                else
                {
                    // Fallback: try direct assignment (will fail at compile if not accessible)
                    sb.AppendLine($"        entity.{entity.IdProperty.Name} = {conversionBody};");
                }
            }
            else
            {
                // Standard conversion (no ValueObject)
                if (entity.IdProperty.HasPublicSetter && !entity.IdProperty.HasInitOnlySetter)
                {
                    sb.AppendLine($"        entity.{entity.IdProperty.Name} = {GetBsonValueExtraction("id", entity.IdProperty.TypeName)};");
                }
                else if (!string.IsNullOrEmpty(entity.IdProperty.BackingFieldName))
                {
                    // Use Expression Tree setter
                    sb.AppendLine($"        var idValue = {GetBsonValueExtraction("id", entity.IdProperty.TypeName)};");
                    sb.AppendLine($"        _set{entity.IdProperty.Name}?.Invoke(entity, idValue);");
                }
                else
                {
                    sb.AppendLine($"        entity.{entity.IdProperty.Name} = {GetBsonValueExtraction("id", entity.IdProperty.TypeName)};");
                }
            }
            
            sb.AppendLine("    }");
        }
        else
        {
            sb.AppendLine($"    public void SetId({entity.Name} entity, BsonValue id)");
            sb.AppendLine("    {");
            sb.AppendLine($"        // No ID property to set");
            sb.AppendLine("    }");
        }
    }
    
    /// <summary>
    /// Replaces parameter name in a lambda body with a new expression
    /// Tries multiple common parameter names (id, value, x, item, str, guid)
    /// </summary>
    /// <param name="lambdaBody">The lambda body (e.g., "id.Value.ToString()")</param>
    /// <param name="firstCommonParameterName">The most likely parameter name to try first</param>
    /// <param name="replacement">The replacement expression (e.g., "entity.Id")</param>
    /// <returns>The body with parameter replaced</returns>
    private static string ReplaceLambdaParameter(string lambdaBody, string firstCommonParameterName, string replacement)
    {
        // Try common parameter names in order of likelihood
        var commonNames = new[] { firstCommonParameterName, "id", "value", "x", "item", "str", "guid", "val" };
        
        foreach (var paramName in commonNames.Distinct())
        {
            // Check if this parameter name exists in the body using word boundaries
            if (System.Text.RegularExpressions.Regex.IsMatch(lambdaBody, $@"\b{System.Text.RegularExpressions.Regex.Escape(paramName)}\b"))
            {
                // Replace it
                return System.Text.RegularExpressions.Regex.Replace(
                    lambdaBody,
                    $@"\b{System.Text.RegularExpressions.Regex.Escape(paramName)}\b",
                    replacement
                );
            }
        }
        
        // If no common name found, return as-is (might be a literal or complex expression)
        return lambdaBody;
    }

    /// <summary>
    /// Generates code to convert C# value to BsonValue
    /// Handles primitives, collections, and nested objects with shared mappers
    /// </summary>
    private static string GetBsonValueConversion(string valueExpression, string typeName, bool isNullable = false, bool isCollection = false, string? collectionItemType = null, bool useSharedMappers = false, string? nestedTypeName = null)
    {
        // Handle collections first
        if (isCollection && collectionItemType != null)
        {
            // Check if collection item is a nested object
            if (useSharedMappers && nestedTypeName != null)
            {
                return $"new BsonArray({valueExpression}.Select(item => {nestedTypeName}Mapper.Serialize(item)))";
            }
            return $"new BsonArray({valueExpression}.Select(item => {GetBsonValueConversion("item", collectionItemType)}))";
        }

        // Handle nested objects with shared mappers
        if (useSharedMappers && nestedTypeName != null)
        {
            return $"{nestedTypeName}Mapper.Serialize({valueExpression})";
        }

        // Handle nullable wrapper
        var expression = typeName switch
        {
            // Primitives
            "int" or "Int32" or "int?" or "Int32?" => $"new BsonValue({valueExpression})",
            "long" or "Int64" or "long?" or "Int64?" => $"new BsonValue({valueExpression})",
            "bool" or "Boolean" or "bool?" or "Boolean?" => $"new BsonValue({valueExpression})",
            "double" or "Double" or "double?" or "Double?" => $"new BsonValue({valueExpression})",
            "float" or "Single" or "float?" or "Single?" => $"new BsonValue((double){valueExpression})",
            "decimal" or "Decimal" or "decimal?" or "Decimal?" => $"new BsonValue({valueExpression})",
            "byte" or "Byte" or "byte?" or "Byte?" => $"new BsonValue((int){valueExpression})",
            "short" or "Int16" or "short?" or "Int16?" => $"new BsonValue((int){valueExpression})",

            // String (always nullable reference)
            "string" or "String" => $"new BsonValue({valueExpression})",

            // Date/Time
            "DateTime" or "DateTime?" => $"new BsonValue({valueExpression})",
            "DateTimeOffset" or "DateTimeOffset?" => $"new BsonValue({valueExpression}.DateTime)",

            // Guid
            "Guid" or "Guid?" => $"new BsonValue({valueExpression})",

            // Binary
            "byte[]" => $"new BsonValue({valueExpression})",

            // Enum (will be converted to int or string based on settings)
            _ when typeName.EndsWith("?") => $"new BsonValue((int){valueExpression})", // Enum nullable
            _ => $"new BsonValue({valueExpression})" // Default - assume enum or convertible
        };

        return expression;
    }

    /// <summary>
    /// Generates code to extract value from BsonValue
    /// Handles primitives, collections, and nested objects with shared mappers
    /// </summary>
    private static string GetBsonValueExtraction(string bsonExpression, string typeName, bool isNullable = false, bool isCollection = false, string? collectionItemType = null, bool useSharedMappers = false, string? nestedTypeName = null)
    {
        // Handle collections first
        if (isCollection && collectionItemType != null)
        {
            // Check if collection item is a nested object
            if (useSharedMappers && nestedTypeName != null)
            {
                return $"{bsonExpression}.AsArray.Select(item => {nestedTypeName}Mapper.Deserialize(item.AsDocument)).ToList()";
            }
            var itemExtraction = GetBsonValueExtraction("item", collectionItemType);
            return $"{bsonExpression}.AsArray.Select(item => {itemExtraction}).ToList()";
        }

        // Handle nested objects with shared mappers
        if (useSharedMappers && nestedTypeName != null)
        {
            return $"{nestedTypeName}Mapper.Deserialize({bsonExpression}.AsDocument)";
        }

        var extraction = typeName switch
        {
            // Primitives
            "int" or "Int32" => $"{bsonExpression}.AsInt32",
            "int?" or "Int32?" => $"{bsonExpression}.IsNull ? (int?)null : {bsonExpression}.AsInt32",
            "long" or "Int64" => $"{bsonExpression}.AsInt64",
            "long?" or "Int64?" => $"{bsonExpression}.IsNull ? (long?)null : {bsonExpression}.AsInt64",
            "bool" or "Boolean" => $"{bsonExpression}.AsBoolean",
            "bool?" or "Boolean?" => $"{bsonExpression}.IsNull ? (bool?)null : {bsonExpression}.AsBoolean",
            "double" or "Double" => $"{bsonExpression}.AsDouble",
            "double?" or "Double?" => $"{bsonExpression}.IsNull ? (double?)null : {bsonExpression}.AsDouble",
            "float" or "Single" => $"(float){bsonExpression}.AsDouble",
            "float?" or "Single?" => $"{bsonExpression}.IsNull ? (float?)null : (float){bsonExpression}.AsDouble",
            "decimal" or "Decimal" => $"{bsonExpression}.AsDecimal",
            "decimal?" or "Decimal?" => $"{bsonExpression}.IsNull ? (decimal?)null : {bsonExpression}.AsDecimal",
            "byte" or "Byte" => $"(byte){bsonExpression}.AsInt32",
            "byte?" or "Byte?" => $"{bsonExpression}.IsNull ? (byte?)null : (byte){bsonExpression}.AsInt32",
            "short" or "Int16" => $"(short){bsonExpression}.AsInt32",
            "short?" or "Int16?" => $"{bsonExpression}.IsNull ? (short?)null : (short){bsonExpression}.AsInt32",

            // String
            "string" or "String" => $"{bsonExpression}.AsString",

            // Date/Time
            "DateTime" => $"{bsonExpression}.AsDateTime",
            "DateTime?" => $"{bsonExpression}.IsNull ? (DateTime?)null : {bsonExpression}.AsDateTime",
            "DateTimeOffset" => $"new DateTimeOffset({bsonExpression}.AsDateTime)",
            "DateTimeOffset?" => $"{bsonExpression}.IsNull ? (DateTimeOffset?)null : new DateTimeOffset({bsonExpression}.AsDateTime)",

            // Guid
            "Guid" => $"{bsonExpression}.AsGuid",
            "Guid?" => $"{bsonExpression}.IsNull ? (Guid?)null : {bsonExpression}.AsGuid",

            // Binary
            "byte[]" => $"{bsonExpression}.AsBinary",

            // Enum (assume int-based)
            _ when typeName.EndsWith("?") => $"{bsonExpression}.IsNull ? ({typeName})null : ({typeName.TrimEnd('?')}){bsonExpression}.AsInt32",
            _ => $"({typeName}){bsonExpression}.AsInt32" // Default - assume enum
        };

        return extraction;
    }

    /// <summary>
    /// Gets default value check for a type
    /// </summary>
    private static string GetDefaultValueCheck(string typeName, bool isNullable)
    {
        if (isNullable || typeName == "string" || typeName == "String")
        {
            return "null";
        }

        return typeName switch
        {
            "int" or "Int32" or "long" or "Int64" or "byte" or "Byte" or "short" or "Int16" => "0",
            "bool" or "Boolean" => "false",
            "Guid" => "Guid.Empty",
            "DateTime" => "DateTime.MinValue",
            "DateTimeOffset" => "DateTimeOffset.MinValue",
            _ => "default"
        };
    }

    /// <summary>
    /// Generates the RegisterMappers partial method
    /// </summary>
    public static string GenerateDbContextPartial(DbContextInfo context)
    {
        var sb = new StringBuilder();

        sb.AppendLine("// <auto-generated/>");
        sb.AppendLine("#nullable enable");
        sb.AppendLine();
        sb.AppendLine("using Community.LiteDB.Aot.Mapping;");

        // Add using statements for entity namespaces
        var entityNamespaces = context.Entities
            .Select(e => e.Namespace)
            .Distinct()
            .Where(ns => ns != context.Namespace) // Don't add using for same namespace
            .OrderBy(ns => ns);

        foreach (var ns in entityNamespaces)
        {
            sb.AppendLine($"using {ns};");
        }

        sb.AppendLine();
        sb.AppendLine($"namespace {context.Namespace};");
        sb.AppendLine();
        sb.AppendLine($"/// <summary>");
        sb.AppendLine($"/// Generated partial class for {context.ClassName}");
        sb.AppendLine($"/// </summary>");
        sb.AppendLine($"partial class {context.ClassName}");
        sb.AppendLine("{");
        sb.AppendLine("    /// <summary>");
        sb.AppendLine("    /// Auto-generated mapper registration");
        sb.AppendLine("    /// </summary>");
        sb.AppendLine("    protected override void RegisterMappers()");
        sb.AppendLine("    {");

        foreach (var entity in context.Entities)
        {
            sb.AppendLine($"        RegisterMapper(new {entity.Name}Mapper());");
        }

        sb.AppendLine("    }");
        sb.AppendLine("}");

        return sb.ToString();
    }

    /// <summary>
    /// Formats a number using invariant culture to avoid locale-specific issues
    /// </summary>
    private static string FormatNumber(object value)
    {
        return value switch
        {
            int i => i.ToString(CultureInfo.InvariantCulture),
            long l => l.ToString(CultureInfo.InvariantCulture) + "L",
            double d => d.ToString("G", CultureInfo.InvariantCulture),
            decimal dec => dec.ToString(CultureInfo.InvariantCulture) + "m",
            float f => f.ToString("G", CultureInfo.InvariantCulture) + "f",
            _ => value.ToString() ?? "0"
        };
    }

    /// <summary>
    /// Formats a number with cast to target type
    /// </summary>
    private static string FormatNumberWithCast(object value, string targetTypeName)
    {
        var formattedValue = FormatNumber(value);

        // If value and target types don't match, add cast
        var valueIsDecimal = value is decimal;
        var valueIsDouble = value is double;
        var targetIsDecimal = targetTypeName == "decimal" || targetTypeName == "Decimal";
        var targetIsDouble = targetTypeName == "double" || targetTypeName == "Double";

        // decimal property with double attribute value: cast to decimal
        if (targetIsDecimal && valueIsDouble)
        {
            // Remove 'd' suffix if present and add 'm'
            formattedValue = formattedValue.TrimEnd('d', 'D') + "m";
        }
        // double property with decimal attribute value: remove 'm' suffix
        else if (targetIsDouble && valueIsDecimal)
        {
            formattedValue = formattedValue.TrimEnd('m', 'M');
        }

        return formattedValue;
    }
}
